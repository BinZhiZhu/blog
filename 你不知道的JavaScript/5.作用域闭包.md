# 整理

闭包是基于词法作用域书写代码时所产生的自然结果
当函数可以记住并访问所在的词法作用域时，就产生了闭包，即函数是在当前词法作用域之外执行

```js
function foo () {
  var a = 2
  function bar () {
    console.log(a)
  }
  return bar
}
var baz = bar()
baz() // 2 闭包的效果
```
函数 bar() 的词法作用域能够访问 foo() 的内部作用域，我们将 bar() 函数本身当做一个值类型进行传递，在自己定义的词法作用域以外的地方执行
这个函数在定义时的词法作用域以外的地方调用
闭包使得函数可以继续访问定义时的词法作用域
无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包
无论通过何种手段将内部函数传递到所在的词法作用域以外，它都会持有对原始定义作用域的引用，无论在何处执行这个函数都会使用闭包

无论何时何地，如果讲函数（访问它们各自的词法作用域）当作第一级的值类型并到处传递，你就会看到闭包在这些函数中的应用。在定时器、事件监听器、Ajax 请求、跨窗口通信、Web Workers 或者任何其他的异步（或者同步）任务中，只要使用了回调函数，实际上就是在使用闭包

尽管 IIFE 本身并不是观察闭包的恰当例子，但它的确创建了闭包，并且也是最常用来创建可以被封闭起来的闭包的工具

```js
for (var i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i*1000)
}
```
根据作用域的工作原理，实际情况是尽管循环中的五个函数式在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个i

```js
for (var i = 1; i <= 5; i++) {
  (function () {
    setTimeout(function timer() {
      console.log(i)
    }, i*1000)
  })()
}
```
IIFE 只是一个什么都没有的空作用域

```js
for (var i = 1; i <= 5; i++) {
  (function (j) {
    setTimeout(function timer() {
      console.log(j)
    }, j*1000)
  })(i)
}
```
在迭代内使用 IIFE 会为每个迭代都生成一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问

```js
for (let i = 1; i <= 5; i++) {
  setTimeout(function timer() {
    console.log(i)
  }, i*1000)
}
```
块作用域和闭包的联合使用

模块模式需要具备两必要条件
- 必须有外部的封闭函数，该函数必须至少被调用一次（每次调用都会创建一个新的模块实例）
- 封闭函数必须返回至少一个内部函数，这样内部函数才能在私有作用域中形成闭包，并且可以访问或者修改私有的状态
一个从函数调用所返回的，只是数据属性而没有闭包函数的对象并不是真正的模块

将模块函数转换IIFE，立即调用这个函数并将返回值直接赋值给单例的模块实例标识符

模块也是普通的函数，可以接受参数

现代的模块机制
```js
var MyModules = (function Manager () {
  var modules = {}

  function define (name, deps, impl) {
    for (var i = 0; i < deps.length; i++) {
      deps[i] = modules[deps[i]]
    }
    modules[name] = impl.apply(impl, deps[i])
  }

  function get (name) {
    return modules[name]
  }
  
  return {
    define: define,
    get: get
  }
})()
```
这段代码的核心是 modules[name] = impl.apply(impl, deps), 为了模块的定义引入了包装函数（可以传入任何依赖），并且将返回值，也就是模块的 API，存储在一个根据名字来管理的模块列表中
```js
MyModules.define('bar', [], function () {
  function hello (who) {
    return 'let me introduce: ' + who
  }
  return {
    hello: hello
  }
})

MyModules.define('foo', ['bar'], function (bar) {
  var hungry = 'hippo'

  function awesome () {
    console.log(bar.hello(hungry).toUpperCase())
  }
  return {
    awesome: awesome
  }
})

var bar = MyModules.get('bar')
var foo = MyModules.get('foo')

console.log(bar.hello('hippo')) // let me introduce: hippo
foo.awesome() // LET ME INTRODUCE: HIPPO
```

基于函数的模块并不是一个能被稳定识别的模块（编译器无法识别），它们的API语义只有在运行时才会被考虑进来，因此可以在运行时修改一个模块的 API
相比之下，ES6 模块 API 更加稳定（API 不会再运行时改变），由于编辑器知道这一点，因此可以在（的确也这样了）编译期检查对导入模块的 API 成员的引用是否真实存在。如果 API 引用并不存在，编译器会在运行时抛出一个或多个“早期”错误，而不是想往常一样在运行期采用动态的解决方案

模块有两个主要特征：
- 为创建内部作用域而调用了一个包装函数
- 包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包
