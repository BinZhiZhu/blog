# 整理

对象可以通过两种形式定义：声明（文字）形式和构造形式，构造形式和文字形式生成的对象是一样的，区别是，文字声明中你可以添加多个键/指对，但是在构造形式中你必须逐个添加属性

#### **#** 类型

JavaScript 中一共有六种主要类型（语言类型）：string, number, boolean, null, undefined, object

简单基本类型 string, number, boolean, null, undefined 本身不是对象
```js
typeof null // object
```
这实际上是语言本身的一个bug，null 本身是基本类型

所以 JavaScript 并非万物皆是对象

JavaScript 中有许多特殊的对象子类型，称为复杂基本类型

函数是对象的一个子类型，"一等公民"，它们本质上和普通的对象一样可以调用，所以可以像操作其他对象一样操作函数（如当作另一个函数的参数）

数组也是对象的一个子类型，具备一些额外的行为，数组中内容的组织方式比一般的对象要稍微复杂一些

_内置对象_

JavaScript 中还有一些对象子类型，通常称为内置对象，有些内置对象的名字看起来和简单基础类型一样，不过实际上它们关系更复杂：String, Number, Boolean, Object, Function, Array, Date, RegExp, Error。

它们实际上只是一些内置函数，这些内置函数可以当作构造函数来使用，从而可以构造一个对应子类型的新对象

```js
var strPrimitive = 'i am a string'
console.log( strPrimitive.length ) // 13
console.log( strPrimitive.charAt(3) ) // 'm'
```
我们可以直接在字符串字面量上访问属性或方法，之所以可以这样做，是因为引擎自动把字面量转成String对象，所以可以访问属性和方法

同样的事情也发生在 `数值字面量` 和 `布尔字面量` 上

#### **#** 内容

对象的内容是由一些存储在特定命名位置的（任意类型的）值组成的，称之为属性

当我们说内容时，似乎在暗示这些值实际上被存储在对象内部，但是这只是它的表现形式。在引擎内部，这些值的存储方式是多钟多样的，一般不会存在对象容器内部。存储在对象容器内部的是这些属性的名称，他们就像指针（引用）一样，指向这些值真正的存储位置

对象属性访问分：

属性访问 `.操作符`：要求属性名满足标识符的命名规范

键访问 `[]操作符`：可以接受任意 UTF-8/Unicode 字符串作为属性名

属性名永远是字符串

_可计算属性名_

ES6 增加了可计算属性名，可以在文字形式中使用 [] 包裹一个表达式来当作属性名，最常用的场景可能是 ES6 的符号 (Symbol)，它们是一种新的基础数据类型，包含一个不透明且无法预测的值（从技术角度来说就是一个字符串）。一般来说不会用到符号的实际值（因为理论上来说在不同的 JavaScript 引擎中值是不同的），所以通常接触到的是符号的名称

_数组_

数组也支持 [] 访问形式

数组期望的是数值下标，也就是值存储的位置（通常称为引索）是整数

```js
var arr = [1, 2, 3]
arr.baz = 'baz'
arr.length // 3
arr.baz // 'baz'
```
数组也是对象，可以给数组添加属性（.语法或者[]语法），数组的length值并未发生变化

数组和普通对象都根据对应的行为和用途进行了优化，所以最好只用对象来存储键/值对，只用数组来存储数值下标/值对

```js
var arr = [1, 2, 3]
arr['3'] = 'baz'
arr.length // 4
arr[3] // 'baz'
```
如果你试图想数组添加一个属性，但属性名‘看起来’像一个数字，那它会变成一个数值下标，因此会修改数组的内容而不是添加一个属性

_复制对象_

ES6 定义了 Object.assign(..)方法来实现浅复制。

Object.assign(..) 方法的第一个参数是目标对象，之后还可以跟一个或多个源对象，它会遍历一个或多个源对象的所有`可枚举 enumerable`的自有键并把它们复制（使用 `=` 操作符赋值）到目标对象，最后返回目标对象

由于 Object.assign(..) 使用 = 操作符来赋值，所以源对象属性的一些特性（比如 writable）不会被复制到目标对象

_属性描述符_

在 ES5 之前，JavaScript 语言本身并没提供可以直接检测属性特性的方法，比如判断属性是否只读。ES5 开始，所有属性都具备了属性描述符
```js
var obj = {
  a: 2
}
Object.getOwnPropertyDescriptor(obj, 'a')
// {
//   value: 2,
//   writable: true,
//   enumerable: true,
//   configurable: true
// }
```
这个普通的对象属性对应的属性描述符（也被称为‘数据描述符’，因为它只保存一个数据值）可不仅仅只是一个2，它还包含另外三个特性：writable(可写)、enumerable(可枚举) 和 configurable(可配置)。在创建普通属性时属性描述符会使用默认值，可以使用 Object.defineProperty(..)来添加一个新属性或者修改一个已有属性（如果它是configurable)并对特性进行设置

`Writable`：决定是否修改属性的值

如果属性的 writable 为 false，在严格模式下修改属性值会抛出一个 TypeError 错误

`Configurable`：只要属性是可配置的，就可以使用 defineProperty(..) 方法来修改属性描述符

如果属性的 configurable 为 false, 不管是不是在严格模式尝试修改一个不可配置的属性描述符都会抛出 TypeError 错误，但可以把 writable 的状态由 true 改为 false，但无法从 false 改为 true，除了无法修改，还会禁止删除这个属性

把 configurable 修改为 false 是单向操作，无法撤销

`Enumerable`：属性是否会出现在对象的属性枚举中

设置为 false，就不会出现在 for .. in 枚举中

_不变性_

1、对象常量：结合 writable: false 和 configurable: false 就可以创建一个真正的常量属性（不可修改、重定义或者删除）

2、禁止扩展: 如果你想禁止一个对象添加新属性并且保留已有属性，可以使用 Object.preventExtensions(..)

```js
var obj = {
  a: 2
}
Object.preventExtensions(obj)
obj.b = 3
obj.b // undefined
```
非严格模式下，创建属性 b 会静默失败，严格模式下，会抛出 TypeError 错误

3、密封

Object.seal(..) 会创建一个'密封'的对象，这个方法实际上会在一个现有对象上调用 Object.preventExtensions(..) 并把所有现有属性标记为 configurable: false

密封之后不能添加新属性，不能重新配置，不能删除任何现有数据，不过可以修改属性的值

4、冻结

Object.freeze(..) 会创建一个冻结对象，这个方法实际上会在一个现有对象上调用 Object.seal(..) 并把所有‘数据访问’属性标记为 writable: false， 这样无法修改它们的值

这个方法是你可以应用在对象上的级别最高的不可变性，它会禁止对于对象本身及其任意直接属性的修改（不过这个对象引用的其他对象不受影响）

_[[ Get \]]_

对象默认的内置 [[ Get \]] 操作首先在对象中查找是否有名称相同的属性，如果找到就会返回这个属性的值，如果没有找到名称相同的属性，按照 [[ Get \]] 算法的定义会执行另外一种非常重要的行为，遍历可能存在的 [[ Prototype \]] 链，也就是原型链，如果无论如何都没有找到名称相同的属性，那 [[ Get \]] 操作会返回值 undefined

这种方法和访问变量时是不一样的，如果你引用了一个当前词法作用域中不存在的变量，并不会像对象属性一样返回 undefined，而是会抛出一个 ReferenceError 异常

但仅从返回undefined 是无法判断变量值为undefined还是变量不存在

_[[ Put \]]_

[[Put\]] 被触发时，实际行为取决于许多因素，包括对象中是否已经存在这个属性

如果存在这个属性，[[Put\]] 算法大致会检查下面这些内容
1. 属性是否是访问描述符？如果是并存在setter就调用setter
2. 属性的数据描述符中 writable 是否是 false ？如果是，在非严格模式下静默失败，在严格模式下抛出 TypeError 异常
3. 如果都不是，将该值设置为属性的值
如果对象中不存在这个属性，[[Put\]] 操作会更加复杂

_Getter 和 Setter_

在ES5中可以使用getter和setter部分改写默认操作，但是只能应用在单个属性上，无法应用在整个对象上

getter是一个隐藏函数，只会在获取属性值时调用

setter是一个隐藏函数，会在设置属性时调用

当你给一个属性定义getter、setter 或者两者都有时，这个属性会被定义为‘访问描述符’（和‘数据描述符’相对）

对访问描述符来说，JavaScript会忽略它们的value和writable特性，取而代之的是关心set和get(还有configurable和enumerable)特性

_存在性_
1. in 操作符会检查属性是否在对象及其原型链中
2. hasOwnProperty(..) 只会检查属性是否在对象中，不会检查原型链

`1 和 2`区别在于是否查找原型链

所有普通对象都可以通过对于Object.prototype的委托来访问 hasOwnProperty(..)，但是有的对象可能没有连接到Object.prototype(通过 Object.create(null)来创建)，这种情况下 myObj.hasOwnProperty(..)会失效

强行判断 Object.prototype.hasOwnProperty.call(myObj, 'a') （借用方法）

propertyIsEnumerable(..) 会检查给定的属性名是否直接存在于对象中（而不是在原型链上）并且满足 enumerable: true

3. Object.keys(..) 返回包含所有可枚举属性的一个数组
4. Object.getOwnPropertyNames(..) 返回一个包含所有无论是否可枚举的属性数组

`3 和 4`只会查找对象直接包含的属性

#### **#** 遍历

1. forEach(..) 遍历数组中所有值并忽略回调函数的返回值
2. every(..) 一直运行直到回调函数返回false或者‘假’值
3. some(..) 一直运行直到回调函数返回ture或者‘真’值

会提前终止遍历

for..in 遍历对象中所有可以枚举的属性，需要手动获取属性值
```js
var arr = [1,2,3]
for (var v of arr) {
  console.log(v)
}
// 1
// 2
// 3
```
for..of 遍历值而不是数组下标（或者对象属性）（ES6）

for..of 循环首先会想被访问对象请求一个迭代器对象，然后通过调用迭代器对象的 next() 方法来遍历所有返回值
