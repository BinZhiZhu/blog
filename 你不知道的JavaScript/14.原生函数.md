# 整理

JavaScript 的内建函数，也叫原生函数：
- String()
- Number()
- Boolean()
- Array()
- Object()
- Function()
- RegExp()
- Date()
- Error()
- Symbol() -- ES6中新加入

```js
var a = new String('abc')
typeof a // "object"
```
typeof 在这里返回的是对象类型的子类型

new String('abc') 创建的是字符串‘abc’的封装对象，而非基本类型值‘abc’

#### **_#_** 内部属性 [[Class\]]

内部属性 [[Class\]] 无法直接查看，一般通过Object.prototype.toString()来查看

```js
Object.prototype.toString.call([1,2,3]) // "[object Array]"
Object.prototype.toString.call(/regex-literal/i) // "[object RegExp]"
Object.prototype.toString.call(null) // "[object Null]"
Object.prototype.toString.call(undefined) // "[object Undefined]"
Object.prototype.toString.call('abc') // "[object String]"
Object.prototype.toString.call(42) // "[object Number]"
Object.prototype.toString.call(true) // "[object Boolean]"
```
虽然 Null() 和 Undefined() 这样的原生构造函数并不存在，但内部[[Class\]]属性值仍然是 "Null" 和 "Undefined"

#### **_#_** 封装对象包装

优先使用 'abc' 和 42 这样的基本类型值，而非 new String('abc') 和 new Number(42)

如果想要自行封装基本类型值，可以使用 Object() 函数（不带new关键字）(不推荐使用)

#### **_#_** 拆封

如果想要得到封装对象中的基本类型值，可以使用 valueOf() 函数

#### **_#_** 原生函数作为构造函数

应该尽量避免使用构造函数，除非十分必要

_Array_

构造函数 Array() 不要求必须带 new 关键字，不带时会自动补上

Array 构造函数只带一个数字参数的时候，该参数会被作为数组的预设长度，而非只充当数组中的一个元素，数组并没有预设长度这个概念

_Object / Function / RegExp_

除非万不得已，否则尽量不要使用 Object() / Function() / RegExp()

没有必要使用 new Object() 来创建对象，因为这样就无法像常量形式那样一次设定多个属性，而必须逐一设定

构造函数Function只有在极少数情况下很有用，比如动态定义函数参数和函数体的时候

强烈建议使用常量形式（如/^a*b+/g）来定义正则表达式，这样不仅语法简单，执行效率也高，因为JavaScript引擎在代码执行前会对它们进行预编译和缓存

_Date / Error_

Date

创建日期对象必须使用 new Date()

Date() 可以带参数，用来指定日期和时间，而不带参数的话则使用当前的日期和时间

主要用来获取当前的Unix时间戳（从 1970 年 1 月 1 日开始计算，以秒为单位），用 getTime() 来获取

从 ES5 开始引入了一个更简单的方法，即静态函数 Date.now()

polyfill:
```js
if (!Date.now) {
  Date.now = function () {
    return (new Date()).getTime()
  }
}
```

Error

Error() 带不带 new 都可以

创建错误对象主要是为了获得当前运行栈的上下文（大部分JavaScript引擎通过只读.stack来访问），栈上下文信息包括函数调用栈信息和产生错误的代码行号，以便于调试

与 throw 一起使用

至少包含一个 message 属性

除 Error() 之外，还有一些针对特定错误类型的原生构造函数，如 EvalError(), RangeError(), ReferenceError(), SyntaxError(), TypeError(), URIError()，它们会在程序发生异常时被自动调用

_Symbol_

ES6新加入的一个基本数据类型：符号（Symbol）

符号是具有唯一性的特殊值（并非绝对），用它来命名对象属性不容易导致重名

符号可以用作属性名，但无论是在代码还是在开发控制台中都无法查看和访问它的值，只会显示为诸如Symbol(Symbol.create)这样的值

```js
obj[Symbol.iterator] = function () {}
```

ES6中有一些预定义符号，以Symbol的静态属性形式出现，如Symbol.create、Symbol.iterator等

不能带new关键字，否则会出错

虽然符号实际上并非私有属性（通过Object.getOwnPropertySymbols()便可以公开获得对象中的所有符号），但它们却主要用于私有或特殊属性

_原生原型_

原生构造函数有自己的 .prototype 对象，包含其对应子类型所特有的行为特征

Function.prototype 是一个空函数

RegExp.prototype 是一个‘空’正则表达式

Array.prototype 是一个空数组

对于未赋值的变量来说，它们是很好的默认值，好处是，.prototype已被创建并且仅创建一次，如果默认值随后会被更改，那就不要使用

