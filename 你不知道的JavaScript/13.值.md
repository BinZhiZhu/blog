# 整理

#### **_#_** 数组

在JavaScript中，数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组

对数组声明后即可向其中加入值，不需要预先设定大小

使用delete运算符可以将单元从数组中删除，但是但删除后数组的length属性并不会发生变化

数组通过数字进行引索，但它们也是对象，也可以包含字符串键值和属性，这些不会计算在数组长度内

```js
var a = [1]
a.lenght // 1
a['1'] = 42
a.lenght // 2
```
如果字符串键值能够被强制类型转换为十进制数字的话，它就会被当做数字引索处理

_类数组_

一些DOM查询操作会返回DOM元素列表

arguments对象将函数参数单做列表来访问（ES6开始已废止）

有时需要将类数组（一组通过数字引索的值）转换为真正的数组，一般通过数组工具函数（indexOf()、concat()、forEach()等）来实现

slice()返回参数列表的一个数组复本，ES6 内置函数Array.from()也能实现同样的功能

#### **_#_** 字符串

JavaScript中的字符串和字符数组都有length属性、indexOf()和concat()方法，并不是一回事

```js
var a = 'foo'
var b = ['f', 'o', 'o']
```

JavaScript中字符串是不可变的，数组是可变的

字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串，而数组的成员函数都是在其原始值上进行操作

许多数组函数用来处理字符串很方便，虽然字符串没有这些函数，但可以通过‘借用’数组的`非变更方法`来处理字符串如：join、map，无法借用数组的可变更方法如：reverse（倒序）

#### **_#_** 数字

只有一种数值类型：number（数字），包括‘整数’和带小数的十进制数

没有真正意义上的整数

中的‘整数’就是没用小数的十进制数，所以42.0即等同于‘整数’42

中是数字类型是基于IEEE754标准来实现的，该标准通常也是被称为浮点数

使用的‘双精度’格式（即64位二进制）

_语法_

数字常量一般用十进制表示

```js
var a = 0.42
var b = .42
```

数字前面的0可以省略

```js
var a = 42.0
var b = 42.
```

小数点后小数部分最后面的0也可以省略

默认情况下大部分数字都以十进制显示，小数点最后面的0被省略

特别大和特别小的数字默认用`指数格式`显示，与toExponential()函数的输出结果相同

`.` 运算符需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符

数字常量还可以用其他格式来表示，如二进制、八进制和十六进制

```js
// 243的十六进制
0xf3
0Xf3

// 243的八进制
0363  // 旧
0o363 // 新
0O363 // 新（不建议使用）

// 243的二进制
0b11110011
0B11110011
```

ES6 开始，严格模式不再支持 0363 八进制格式，但非严格模式下仍然支持

建议使用 0x，0o, 0b

_较小的数字值_

二进制浮点数中的0.1和0.2并不是十分精确，它们相加的结果并非刚好等于0.3，而是一个比较接近的数字0.30000000000000004

设置一个误差范围值（机器精度）为2^-52（2.220446049250313e-16）

ES6中定义在Number.EPSILON中，ES6之前的：

```js
if (!Number.EPSILON) {
  Number.EPSILON = Math.pow(2, 15)
}
```

能够呈现的最大浮点数大约是1.7976931348623157e+308，ES6定义在 Number.MAX_VALUE 中

能够呈现的最小浮点数大约是5e-324，ES6定义在 Number.MIN_VALUE 中，非负数，无限接近于0

_整数的安全范围_

数字的呈现方式决定了‘整数’的安全值范围远远小于Number.MAX_VALUE

安全呈现的最大整数是 9007199254740991，ES6定义在 Number.MAX_SAFE_VALUE 中

安全呈现的最小整数是-9007199254740991，ES6定义在 Number.MIN_SAFE_VALUE 中

_整数检测_

ES6 Number.isInteger() 检测一个值是否整数

ES6 之前 polyfill Number.isInteger() 方法：

```js
if (!Number.isInteger) {
  Number.isInteger = function (num) {
    return typeof num == 'number' && num % 1 == 0
  }
}
```

ES6 Number.isSafeInteger() 检测一个值是否安全的整数

ES6 之前 polyfill Number.isSafeInteger() 方法：

```js
if (!Number.isSafeInteger) {
  Number.isSafeInteger = function (num) {
    return Number.isInteger(num) &&
      Math.abs(num) <= Number.MAX_SAFE_INTEGER
  }
}
```

#### **_#_** 特殊数值

_不是值的值_

undefined 类型只有一个值 undefined，从未赋值，一个标识符，可以用来，当做变量

null 类型只有一个值 null，曾经赋过值，但目前没有值，一个特殊的关键字，不是标识符，不能作为变量

`永远不要重新定义 undefined`

如果要将代码中的值（如表达式的返回值）设为 undefined ，就可以使用 void

_特殊的数字_

**_1_** `NaN`

如果数字运算的操作数不是数字类型（或者无法解析为常规的十进制或者十六进制数字）就无法返回一个有效的数字，这种情况下返回值为 NaN，但仍是数字类型

NaN 意指‘无效数值’‘失败数值’或者‘坏数值’，是一个‘警戒值’，用于指出数字类型中的错误情况，即‘执行数字运算没有成功，这是失败后返回的结果’

NaN 是一个特殊值，唯一一个非自反的值，而 NaN != NaN 为 true

ES6 中使用 Number.isNaN() 来判断

ES6 之前 polyfill Number.isNaN() 方法：

```js
if (!Number.isNaN) {
  Number.isNaN = function (n) {
    return (
      typeof n === 'number' &&
      window.isNaN(n)
    )
  }
}
// 或者
if (!Number.isNaN) {
  Number.isNaN = function (n) {
    return n !== n
  }
}
```

**_2_** `Infinity 和 -Infinity`

JavaScript 的运算结果可能溢出，结果为 Infinity 或者 -Infinity

可以从有穷走向无穷，但无法从无穷回到有穷

Infinity/Infinity是一个无定义操作，结果为NaN

有穷正数除以 Infinity 返回 0

有穷负数除以 Infinity 返回 -0

**_3_** `0 和 -0`

-0 可以用来作常量，也可以是某些数学运算的返回值

`0 === -0 // true`

+ 和 - 运算不会得到 `-0`

对数字 -0 进行字符串化会返回 '0'

对字符串 '-0' 转换为数字返回 -0

`-0` 多数情况下用在动画上，`-` 表示方向

**_4_** `Object.is()`

ES6 中新加，用来判断两个值是否绝对相等，主要用来处理那些特殊值的相对比较

ES6 之前 polyfill Object.is() 方法：

```js
if (!Object.is) {
  Object.is = function (v1, v2) {
    // 判断是否是 -0
    if (v1 === 0 && v2 === 0) {
      return 1 / v1 === 1 / v2
    }
    // 判断是否是 NaN
    if (v1 !== v1) {
      return v2 !== v2
    }
    //其他情况
    return v1 === v2
  }
}
```

能使用 == 和 === 的使用尽量不要使用 Object.is()，前者效率高


#### **_#_** 值和引用

JavaScript 对值和引用的赋值/传递在语法上没有区别，完全根据值的类型来决定

简单值（标量基本类型值）通过复制的方式来赋值/传递，包括 null，undefined，字符串，数字，布尔，symbol

复合值，通过引用复制的方式来赋值/传递，包括对象和函数

引用指向值本身而非变量

无法自行决定使用值复制还是引用复制，一切由值的类型来决定

标量基本类型值是不可变的（数字，字符串，布尔值）
