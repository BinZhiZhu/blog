# 整理

变量住在哪里？换句话说，他们存储在哪里？最重要的是，程序需要时如何找到它们
尽管 JavaScript 归类为动态或解释执行语言，但事实上它是一门编译语言

在传统编译语言的流程中，源代码在执行之前会经历三个步骤，统称为编译：
- 分词/词法分析
- 解析/语法分析
- 代码生成

JavaScript 的编译过程不是发生在构建之前的，大部分情况下编译发生在代码执行前的几微妙（甚至更短）的时间内， JavaScript 引擎用尽了各种办法（比如JIT，可以延迟编译甚至实施重编译）来保证性能最佳，简单说，任何 JavaScript 代码片段在执行前都要编译（通常就在执行前）

代码处理过程涉及部分：
- 引擎：从头到尾负责整个 JavaScript 程序的编译及执行过程
- 编译器：负责语法分析及代码生成
- 作用域：负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限

`var a = 2` 当`引擎`看到这句话时会认为这里有两个完全不同的声明：
- 一个由编译器在编译时处理
  编译器会询问作用域是否已经有一个该名称的变量存在同一个作用域，如果是，编译器会忽略该声明，否则它会要求作用域在当前作用域中声明一个新的变量并命名为a
- 一个由引擎在运行时处理
  编译器会为引擎生成运行时所需要的代码，这些代码被用来处理 a = 2 这个赋值操作
  引擎运行时会首先询问作用域，当前作用域是否有个叫a的变量，如果是，引擎会使用这个变量，否则，引擎会继续找该变量

`LHS` 和 `RHS` 的含义是赋值操作的左侧或者右侧，并不意味着就是 = 号赋值操作符的左侧或者右侧，赋值操作还有其他几种形式，所以在概念上最好将其理解为“赋值操作的目标是谁（LHS）”和“谁是赋值操作的源头（RHS）” 

编译器可以在代码生成的同事处理声明和值的定义

当一个块或函数嵌套在另一个块或函数中时，就发生了作用域的嵌套，因此在当前作用域中无法找到某个变量时，引擎就会在外层嵌套的作用域中继续查找，直到找到该变量，或者抵达最外层的作用域（也就是全局作用域）为止，到达最外层时，无论找没找到，查找过程都会停止

如果 RHS 查询在所有嵌套的作用域中遍寻不到所需的变量，引擎会抛出 `ReferenceError` 异常
引擎在非严格模式执行LHS查询，在全局作用域中也无法找到目标变量，全局作用域中就会创建一个具有该名称的变量，并将其返还给引擎，在严格模式下则不会创建并返回一个全局变量，引擎会抛出同RHS查询失败时类似的 `ReferenceError` 异常

如果找到一个变量了，但是尝试对这个变量的值进行非法或者不合理的操作，引擎会抛出 `TypeError` 异常

# 归纳

JavaScript 通常在执行前编译

处理代码的参与者：
- 引擎：负责整个编译执行过程
- 编译器：语法分析及代码生成
- 作用域：管理所有变量，有一套严格的规则确定变量的访问权限

LHS：对谁做赋值操作
RHS：对谁做读取操作

在一个作用域中如果找到不该变量就会在外层嵌套的作用域中查找，直到找到该变量或者到了最外层的作用域，无论有没有找到，查找都会停下来，之后：
- 非严格模式下：
  RHS 找不到变量引擎抛出 ReferenceError 异常
  LHS 找不到变量会自动创建一个全局变量并对这个变量做赋值操作
- 严格模式下：
  RHS 找不到变量引擎抛出 ReferenceError 异常
  LHS 找不到变量引擎抛出类似 ReferenceError 异常

找到变量但是做了不合理的操作，引擎会抛出 TypeError 异常
