# 整理

调用栈，为了到达当前执行位置所调用的所有函数（浏览器调试工具可以查看到）

**_默认绑定_**

最常用的函数调用类型：独立函数调用
```js
function foo () {
  console.log(this.a)
}
var a = 2
foo() // 2
```
foo() 是直接使用不带任何修饰的函数引用进行调用的，因此只能使用默认绑定，无法应用其他规则
```js
'use strict'
function foo () {
  console.log(this.a)
}
var a = 2
foo() // TypeError: this is undfined
```
虽然 this 的绑定规则完全取决于调用位置，但是只有 foo() 运行在非 strict mode 下时，默认绑定才能绑定到全局对象，strict mode 下与 foo() 的调用位置无关，this 会绑定到 undefined

**_瘾式绑定_**

当函数引用有上下文对象时，隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象

```js
function foo () {
  console.log(this.a)
}
var obj = {
  a: 2,
  foo: foo
}
obj.foo() // 2
```
需要注意的是 foo() 的声明方式，及其之后是如何被当作引用属性添加到 obj 中的，无论是直接在 obj 中定义还是先定义再添加为引用属性，这个函数严格来说都不属于 obj 对象，然而，调用位置会使用 obj 上下文来引用函数

对象属性引用链中只有最顶层或者说最后一层会影响调用位置
```js
function foo () {
  console.log(this.a)
}
var obj2 = {
  a: 42,
  foo: foo
}
var obj1 = {
  a: 2,
  obj2: obj2
}
obj1.obj2.foo() // 42
```
注意
```js
function foo () {
  console.log(this.a)
}
var obj = {
  a: 2,77
  foo: foo
}
var bar = obj.foo // 函数别名
var a = 'oops, global' // a 是全局对象的属性
bar() // oops, global
```
`绑定丢失`：bar 是 obj.foo 的一个引用，实际上引用的是 foo 的函数本身，此时的 bar() 是一个不带任何修饰的函数调用，因此应用了默认绑定。绑定丢失还发生在传入回调函数，传入语言内置函数setTimeout等

**_显示绑定_**

```js
function foo () {
  console.log(this.a)
}
var obj = {
  a: 2
}
foo.call(obj) // 2
```
调用 call(..) 和 apply(..) 显示绑定 this
它们的第一个参数是对象，它们会把这个对象绑定到 this，接着在调用函数时指定这个 this

如果你传入了一个原始值（字符串类型、布尔类型或者数字类型）来当做 this 的绑定对象，这个原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..))，这通常被称为“装箱”

从 this 绑定的角度来说，call(..) 和 apply(..) 是一样的，它们的区别体现在其他的参数上，但是现在我们不用考虑这些

**_new绑定_**

JavaScript 中，new 的机制实际上和面向类的语言完全不同
JavaScript 中，构造函数只是一些使用 new 操作符时被调用的函数，它们并不会属于某个类，也不会实例化一个类，实际上，它们甚至不能说是一种特殊的函数类型，它们只是 new 操作符调用的普通函数而已

包括内置对象函数在内的所有函数都可以用 new 来调用，称为构造函数调用
实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”

使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作：
1. 创建（或者说构造）一个全新的对象
2. 这个新对象会被执行`[[原型]]`链接
3. 这个新对象会绑定到函数调用的 this
4. 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象

```js
function foo (a) {
  this.a = a
}
var bar = new foo(2)
console.log(bar.a) //2
```
使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上，称之为 new 绑定

**_判断 this_**

如果判断一个运行中函数的 this 绑定，就需要找到这个函数的直接调用位置，找到之后就可以顺序应用下面这四条规则来判断 this 的绑定：
1. 由 new 调用？绑定到新创建的对象
2. 由 call 或者 apply（或者 bind ）调用？绑定到指定的对象
3. 由上下文对象调用？绑定到那个上下文对象
4. 默认，在严格模式下绑定到 undefined，否则绑定到全家对象

一定要注意，有些调用可能在无意中使用默认绑定规则

**_被忽略的 this_**

如果你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值再调用时会被忽略，实际应用的是默认绑定
如果函数并不关系 this 的话，你仍然需要传入一个占位符，这时 null 可能是个不错的选择

**_箭头函数_**

ES6 中介绍了一种无法使用这些规则的特殊函数类型：箭头函数，根据外层（函数或者全局）作用域来决定this
箭头函数常用于回调函数
