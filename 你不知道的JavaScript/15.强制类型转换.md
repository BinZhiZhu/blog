# 整理

#### **#** 值类型转换

强制类型转换总是返回标量基本类型值，如字符串、数字和布尔值，不会返回对象和函数

类型转换发生在静态类型语言的编译阶段，强制类型转换则发生在动态类型语言的运行时

强制类型转换：隐式强制类型转换 和 显式强制类型转换

```js
var a = 42
var b = a + ''    // 隐式强制类型转换
var c = String(a) // 显式强制类型转换
```

#### **#** 抽象值操作

**ToString**

负责处理非字符串到字符串的强制类型转换

基本类型值的字符串化规则为：null 转换为 'null'，undefined 转换为 'undefined'，true 转换为 'true'

数字的字符串化则遵循通用规则，不过那些极小和极大的数字使用指数形式（'1.07e21'）

如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值

```js
var a = [1, 2, 3]
a.toString() // "1,2,3"
```
数字的默认 toString() 方法经过了重新定义，将所有单元字符串化以后再用`,`连接起来

toString() 可以被显示调用，或者在需要字符串化时自动调用

_JSON 字符串化_ （并不是强制类型转换）

工具函数 JSON.stringify() 在将JSON对象序列化为字符串时也用到了 ToString

```js
JSON.stringify(42) // "42"
JSON.stringify("42") // ""42""（含有双引号的字符串）
JSON.stringify(null) // "null"
JSON.stringify(true) // "true"
```
JSON 字符串化和 toSting 的效果基本相同，只不过序列化的结果总是字符串

```js
JSON.stringify(undefined) // undefined
JSON.stringify(function(){}) // undefined
JSON.stringify(
  [1, undefined, function(){}, 4]
) // "[1,null,null,4]"
JSON.stringify(
  { a:2, b: function(){}}
) // "{"a":2}"
```
JSON.stringify 在对象中遇到 undefined、function 和 symbol 时会自动将其忽略，在数组中则返回 null（以保证单元位置不变）

如果对象中定义了 toJSON 方法，JSON 字符串化时会首先调用该方法，然后用它的返回值来进行序列化

toJSON() 应该是一个安全的JSON的值

1. 字符串、数字、布尔值 和 null 的 JSON.stringify() 规则与 ToString 基本相同
2. 如果传递 JSON.stringify() 的对象中定义了 toJSON() 方法，那么该方法在字符串化前调用，以便将对象转为安全的 JSON 值

**ToNumber**

负责处理非数字到数字的强制类型转换

其中 true 转换为 1，false 转换为 0，undefined 转换为 NaN，null 转换为 0

ToNumber 对字符串的处理基本遵循数字常量的相关规则/语法，处理失败时返回 NaN（处理数字矢量失败时会产生语法错误），不同之处是 ToNumber 对以 0 开头的十六进制并不按十六进制处理（而是按十进制）

对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字

为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先通过内部操作 DefaultValue 检查该值是否有 valueOf() 方法，如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值来进行强制类型转换，如果 valueof() 和 toString() 均不返回基本类型值，会产生 TypeError 错误

ES5 开始，使用 Object.create(null) 创建的对象 [[Prototype\]] 属性为 null ，并且没有 valueof() 和 toString() 方法，因此无法进行强制类型转换

**ToBoolean**

JavaScript 中有两个关键词 true 和 false，分别代表布尔类型中的真和假，1 和 0 可以被强制类型转换为 true 和 false，但在JavaScript中，它们不是一回事

_假值_

JavaScript 中的值可以分为以下两类
1. 可以被强制类型转换为 false 的值
2. 其他（被强制类型转换为 true 的值）

JavaScript 规范具体定义了一小撮可以被强制类型转换为 false 的值
- undefined
- null
- false
- +0、-0 和 NaN
- ""

_假值对象_

虽然 JavaScript 代码中会出现假值对象，但它实际上并不属于 JavaScript 语言的范畴

浏览器在某些特定情况下，在常规 JavaScript 语法基础上自己创建了一些外来值，这些就是假值对象

假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为 false

常见的例子是 document.all（中 P55）

_真值_

假值列表之外的值


#### **#** 显示强制类型装换

**字符串和数字之间的显式转换**

```js
var a = 42
var b = String(a)

var c = '3.14'
var d = Number(c)

b // "42"
d // 3.14
```
字符串和数字之间的转换是通过 String() 和 Number() 这两个内建函数来实现的，不用 new 调用，并不是创建封装对象

String() 遵循 ToString 规则，将值装换为字符串基本类型
Number() 遵循 ToNumber 规则，将值装换为数字基本类型

```js
var a = '3.14'
var b = +a
b // 3.14
```
+ 运算符的一元形式（即只有一个操作数），+ 运算符显式地将a转换为数字，而非数字加法运算

- 运算符和 + 一样，而且它还会反转数字的符号位（注意 -- 是被当作递减元算符来处理，所以要用 - - 来取消反转）

_日期显式转换为数字_

```js
var a = new Date('Fri Aug 25 2017 07:57:34 GMT+0800')
+d // 1503619054000
```
+ 运算符将日期对象强制类型转换为数字，以微妙为单位（不建议），和 ES5 中 Date.now() 效果一样，或者 new Date().getTime() 来获取指定时间戳

_奇特的 ~ 运算符_

~x 大致等同于 -(x+1)，`~42 // -(42+1) `

在 -(x+1) 中唯一能够得到 0（或者严格说是 -0）的 x 值是 -1，也就是说如果 x 为 -1 时，~ 和一些数字在一起会返回假值 0，其他情况则返回真值

-1 是一个 ‘哨位值’（特殊含义的值），在 C 语言中我们用 -1 来代表函数执行失败，用 >= 0 的来表示函数执行成功，JavaScript 中也是一样

\>= 和 == -1 写法不是很好，称为‘抽象渗漏’，意思是在代码中暴露了底层的实现细节，这里是指用 -1 作为失败时的返回值，这些细节应该被屏蔽掉

返回 -1，~ 将其转换为假值 0，其他情况一律转换为真值

由 -(x+1) 推断 ~-1 的结果应该是 -0，然而实际结果是 0，因为它是字位操作而非数字运算

_字位截除_

~~ 中的第一个 ~ 执行 ToInt32 并反转字位，然后第二个 ~ 再进行一次字位反转，即将所有字位反转回原值，最后得到的仍是 ToInt32 的值，只适用于 32位数字，更重要的是它对负数的处理与 Math.floor() 不同

\~~x 能将值截除为一个32位整数，x | 0 也可以


**显式解析数字字符串**

```js
var a = "42"
var b = "42px"
Number(a) // 42
Number(b) // NaN
parseInt(a) // 42
parseInt(b) // 42
```
解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止，而转换不允许出现非数字字符，否则失败并返回 NaN

解析字符串中的浮点数可以使用 parseFloat()

parseInt() 是针对字符串的

_解析非字符串_

parseInt() 会将参数强制转换为字符串再进行解析

```js
parseInt(1/0, 19) // 18
```

在实际上，JavaScript 代码中不会用到基数 19，它的有效数字范围是 0-9 和 a-i (区分大小写)

parseInt(1/0, 19) 实际上是 parseInt('Infinity', 19)，第一个字符是’I‘，以19为基数时值为18，第二个字符’n‘不是一个有效的数字字符，解析停止


**显式转换为布尔值**

与前面的 String() 和 Number() 一样，Boolean()（不带new）是显式的 ToBoolean 强制类型转换

一元运算符 ! 显示地将值强制类型转换为布尔值，它同时还将值取反，所以 !! 会反转回原值

建议使用 Boolean() 和 !!a 来进行显式强制类型转换

#### **#** 隐式强制类型装换

**字符串和数字之间的隐式强制类型转换**

简单来说就是，如果 + 的其中一个操作数是字符串则进行字符串拼接，否则执行数字加法

a + ''（隐式） 和前面的 String(a) （显式）之间有一个细微的差别需要注意。根据 ToPrimitive 抽象操作规则，a + '' 会对 a 调用 valueOf() 方法，然后通过 ToString 抽象操作将返回值转换为字符串。而 String(a) 则直接调用 ToString()

**隐式强制类型转换为布尔值**

1. if() 中的条件判断表达式
2. for() 中条件判断表达式（第二个）
3. while() 和 do..while() 循环中的条件判断表达式
4. ? : 中的条件判断表达式
5. 逻辑运算符 || (逻辑或) 和 &&（逻辑与）左边的操作符（作为条件判断表达式）

**|| 和 &&**

它们的返回值是两个操作数中的一个（且仅一个），并不一定是布尔类型，而是两个操作数其中一个值

首先会对第一个操作符执行条件判断，如果其不是布尔值就先进行 ToBoolean 强制类型转换，然后在执行条件判断

对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值
对于 && 来说，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值

```js
function foo () {
  console.log(a)
}
var a = 42
a && foo() // 42p
```
如果第一个操作数为真值，则 && 运算符“选择”第二个操作数作为返回值，这也叫作“守护运算符”，即前面的表达式为后面的表达式“把关”

**符号的强制类型转换**

```js
var s1 = Symbol('cool')
String(s1)
var s2 = Symbol('not cool')
s2 + '' // TypeError
```
ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误

符号不能被强制类型转换为`数字`（显式和隐式都会产生错误）

可以被强制类型转换为`布尔值`（显式和隐式的结果都是true）

#### **#** 宽松相等和严格相等

