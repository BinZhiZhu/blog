# 整理

作用域包含了一系列的气泡，每一个都可以作为容器，其中包含了标识符（变量、函数）的定义，这些气泡相互嵌套并且整齐地排列成蜂窝型，排列的结构是在写代码时定义的

函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）
如果不细心处理这些可以在整个作用域范围内被访问的变量，可能会带来意想不到的问题

可以把变量和函数包裹在一个函数的作用域中，然后用这个作用域隐藏它们（从最小特权原则或者最小授权或者最小暴露原则引申出来的，在软件设计中，应该最小限度地暴露必要内容而将其他内容都隐藏起来）

隐藏作用域中的变量和函数所带来的另一个好处，是可以避免同名标识符之间的冲突

- 全局命名空间
- 模块管理

以（function...开头的函数会被当作函数表达式

```js
function foo () {
  // ...
}
```
foo 被绑定在所在的作用域中

```js
(function foo () {
  // ...
})()
```
foo 被绑定在`函数表达式自身的函数`中

`(function foo () {..})` 作为函数表达式意味着foo只能在 .. 所代表的位置中被访问，外部作用域则不行

函数表达式可以匿名，函数声明则不能省略函数名

匿名函数表达式的缺点：
- 匿名函数在栈追踪中不会显示出有意义的函数名，使得调试很困难
- 如果没有函数名，当函数需要引用自身时只能使用已经过期的 arguments.callee 引用，比如递归中
- 匿名函数省略了对代码可读性/可理解性很重要的函数名

给匿名函数表达式起个名字可以解决上述问题（行内函数表达式）

立即执行函数表达式(IIFE)：函数被包含在一对()括号内部，因此成为了一个表达式，通常在末尾加上另一个()可以立即执行这个函数，函数名对IIFE不是必须的
传统形式：`(function () {..})()`
改进形式：`(function () {..}())`
进阶用法：把它们当作函数调用并传递参数进去
```js
var a = 2
(function IIFE (global) {
  var a = 3
  console.log(a) // 3
  console.log(global.a)
})(window)
console.log(a)
```

这个模式的另一个应用场景是解决 undefind 标识符的默认值被错误覆盖导致的异常（虽然不常见）
将一个参数命名为undefined，但是在对应的位置不传入任何值，这样可以保证代码块中undefined标识符的值真的是undefined
```js
undefined = true // 挖坑，不要这么做
(function IIFE (undefined) {
  var a
  if (a === undefined) {
    console.log('undefined is safe here')
  }
})
```

IIFE还有一种变化的用途是倒置代码的运行顺序，将需要运行的函数放在第二位，在IIFE执行之后当作参数传递进去，这种模式在 UMD (Universal Module Definition) 项目中被广泛使用

```js
for (var i = 0; i < 10; i++) {
  console.log(i)
}
```
i 会被绑定在外部作用域（函数或者全局）中

当用 var 声明变量时，它写在哪里都是一样的，因为它们最终都会属于外部作用域

块作用域是一个用来对之前的 `最小授权` 原则进行扩展的工具，将代码从在函数中隐藏信息，扩展为在 `块中隐藏信息`
可惜表面上看 JavaScript 并没有快作用域的相关功能

ES6前
with、try/catch(catch分词会创建一个块作用域，声明的变量仅在catch内部有效) 会创建块作用域

ES6后
let 关键字可以将变量绑定到所在的任务作用域中（通常是 {..} 内部）

```js
var foo = true
if (foo) {
  { // <-- 显式的块
    let bar = foo * 2
  }
}
console.log(bar) // ReferenceError
```
只要声明是有效的，在声明中的任意位置都可以使用 {..} 括号来为 let 创建一个用于绑定的块

提升是指声明会被视为 `存在于其所出现的作用域的整个范围内`，但是使用 let 进行的声明不会在块作用域中进行提升

块作用域有利于垃圾收集
for 循环头部的 let 不仅将 i 绑定到了 for 循环的块中，事实上，它将其重新绑定到了循环的每一个迭代中，确保使用上一个循环迭代结束时的值重新进行赋值

let 声明附属于一个新的作用域而不是当前的函数作用域

const 其值是固定的（常量），试图修改值的操作都会引起错误

函数是 JavaScript 中最常见的作用域单元
块作用域指的是变量和函数不仅可以属于所处的作用域，也可以属于某个代码块（通常指 {..} 内部）
`if (..) { let a = 2 }` 会声明一个劫持了 if 的 {..} 块变量