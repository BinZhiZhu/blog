# 整理

内置属性 prototype 其实就是对于其他对象的引用，几乎所有的对象在创建时就会被赋予一个非空值

对于默认的 [[get\]] 操作，如果在对象本身找到需要的属性，就会继续访问对象的 prototyp 链，如果还是找不到，则会返回 undefined

使用in操作符来检查属性在对象中是否存在，也会查找对象的整条原型链（无论属性是否可枚举）

当通过各种语法进行属性查找时都会查找 prototype 链，直到找到属性或者找完整条原型链

Object.create(..) 会创建一个"新"对象并把新对象内部的 prototype 关联到指定的对象

所有普通的 prototype 链最终都会指向内置的 Object.prototype，该对象包含JavaScript中许多通用的功能，.toString(), .valueOf(), .hasOwnProperty(..), .isPrototypeOf(..) 等

JavaScript中只有对象

```js
function Foo() {
	// ...
}
Foo.prototype; // {}
```

所有函数默认都会拥有一个名为 prototype 的共有并且不可枚举的属性，例子中，它会指向被称为 Foo 的原型的对象，这个对象是在调用 new Foo() 时创建的，最后被关联到 Foo.prototype 上

```js
const a = new Foo()
```

调用 new Foo() 时会创建 a ，其中一步就是给 a 一个内部的 prototype 关联到 Foo.prototype 指向的那个对象

JavaScript中没有复制机制，不能创建一个类的多少个实例，只能创建多个对象，他们的  	prototype 关联的是同一个对象，他们是互相关联的

new Foo() 这个函数调用实际上并没有直接创建关联，这个关联只是一个意外的副作用，一个关联到其他对象的新对象

继承意味着复制操作，JavaScript默认并不会复制对象属性，相反，JavaScript会在两个对象之间创建一个关联，这样的一个对象就可以通过委托访问另一个对象的属性和函数了

```js
function Foo() {
	// ...
}
Foo.prototype.constructor === Foo // true
const a = new Foo()
```
Foo.prototype 默认（在代码的第一行声明时！）有一个公有并且不可枚举的属性 .constructor，这个属性引用的是对象关联的函数

用 new Foo() 创建的对象也有一个 .constructor 属性，指向“创建这个对象的函数”（创建的对象本身并没有 .constructor 属性，而是委托给了 Foo.prototype， Foo.prototype.constructor 默认指向 Foo ）

函数本身并不是构造函数，当你在普通函数调用前面加上 new ，就会把这个函数调用变成一个“构造函数调用”，和传统面向类语言中的类构造函数不一样

new 会劫持所有普通函数并用构造对象的形式来调用

Foo.prototype 的 .constructor 属性只是 Foo 函数`在声明时`的默认属性

constructor 并不代表被构造，并不是一个不可变属性，他是不可枚举，但是指可以改写，所以.constructor 是一个非常不可靠并且不安全的引用

所以要创建一个关联对象，我们必须使用 Object.create(..) 而不是使用具有副作用的 Foo(..)（用new的构造函数调用会生成 .prototype 和 .constructor 引用），这样做唯一的缺点就是需要创建一个新对象然后把旧对象抛弃掉，不能直接修改已有的默认对象

_修改对象的 prototype 关联的可靠方法_：
```js
// ES6之前
Bar.prototpye = Object.create( Foo.prototype )

// ES6开始
Object.setPrototypeOf( Bar.prototype, Foo.prototype )
```

_获取一个对象的 prototype链_：
```js
// ES5 
Object.getPrototype(a)

// ES6前非标准，ES6后为标准方法
a._proto_ === Foo.prototype // true
```
`._proto_` 也是常用函数(.toString()、.isPrototypeOf(..))，不存在你正在使用的那个对象，存在内置的 Object.prototype 中，它们是不可枚举的

关联两个对象最常用的方法是使用 new 关键词进行函数调用


# 归纳

- JavaScript 中对象都有 prototpye 属性，值一般非空
- 涉及对象属性查找的，如果对象没有这个属性，就会上 prototype 链上找，直到找到为止，如果搜索完依旧无该属性，就返回 undefined
- JavaScript 不存在一个类产生多个实例，只能产生多个对象，他们的 prototype 关联到一个对象上
- 函数只是函数，并没有存在什么构造函数，只是调用方式的问题，被 new 调用的函数调动称为构造函数调用
- new 调用的 fun ，会生成一个对象，让 fun.prototype 关联这个对象 (把这个对象称为 fun.prototype 的对象 )
- new 调用 fun 生成的对象的 prototype ，也会指向上一条中所说的那个对象
- .constructor 是函数在声明时, fun.prototype 的一个默认属性，这个属性并不安全，可以被篡改
- 使用无副作用的 Object.create(..) 创建对象
- 修改对象prototype关联的可靠方法：
	- ES6之前：
		`Bar.prototype = Object.create(Foo.prototype)`
	- ES6之后：
		`Object.setPrototypeOf(Bar.prototype, Foo.prototype)`
- 获取一个对象的 prototype 的可靠方法
	- ES6之前：
		`Object.getPrototpyeOf(Bar)`
	-	ES6之后：
		`Bar._proto_`
