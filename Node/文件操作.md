# 整理

### 小文件
fs.readFileSync 从源路径读取文件内容
fs.writeFileSync 将文件内容写入目标路径
process 是一个全局变量，可以通过 process.argc 获取命令行参数，argv[0] 固定等于 NodeJs 执行程序的绝对路径， argv[1] 固定等于主模块的绝对路径，因此第一个命令行参数从 argv[2] 开始

### 大文件
fs.createReadSteam 创建一个文件的只读数据流
fs.createWriteSteam 创建了一个目标文件的只写数据流
并且用 pipe 把两个数据流连接了起来

**_Buffer_**

**_Stream_**
当内存中无法一次装下需要处理的数据时，或者一边读取一边处理更加高效时，我们应该选择数据流 Stream
Stream 基于事件机制工作，所有 Stream 的实例都基于 NodeJs 提供的EventEmitter
```js
var rs = fs.createReadStream(pathname)
rs.on('data', function (chunk) {
  doSomething(chunk)
})
rs.on('end', function () {
  cleanUp()
})
```
上边的代码中 data 事件会源源不断地被触发，不管 doSomething 函数是否处理得过来，改造如下
```js
var rs = fs.createReadStream(pathname)
// 触发
rs.on('data', function (chunk) {
  // 暂停
  rs.pause()
  // 做某些操作，完事后调用回调函数继续读取 chunk
  doSomething(chunk, function () {
    rs.resume()
  })
})
rs.on('end', function () {
  cleanUp()
})
```
为数据目标创建一个只写数据流
```js
var rs = fs.createReadStream(src)
var ws = fs.createWriteStream(dst)
// 触发
rs.on('data', function (chunk) {
  ws.write(chunk)
})
rs.on('end', function () {
  ws.end()
})
```
如果写入速度跟不上读取速度的话，只写数据流内部的缓存会爆表，改造如下
```js
var rs = fs.createReadStream(src)
var ws = fs.createWriteStream(dst)
// 触发
rs.on('data', function (chunk) {
  // 防爆表控制
  if (ws.write(chunk) === false) {
    rs.pause()
  }
})
rs.on('end', function () {
  ws.end()
})
ws.on('drain', function () {
  rs.resume()
})
```
NodeJs 直接提供了 .pipe 方法来做这事，其内部实现方式与上边的代码类似

**_File System_**
文件属性读写：fs.stat、fs.chmod、fs.chown 等
文件内容读写：fs.readFile、fs.readdir、fs.writeFile、fs.mkdir 等
底层文件操作：fs.open、fs.read、fs.write、fs.close 等

NodeJS 最精华的异步 IO 模型在 fs 模块里有着充分的体现，上边提到的这些API都通过回调函数传递结果。以fs.readFile为例：
```js
fs.readFile(pathname, function (err, data) {
  if (err) {
    // Deal with error.
  } else {
    // Deal with data.
  }
})
```
基本上所有 fs 模块API的回调参数都有两个。
第一个参数在有错误发生时等于异常对象，第二个参数始终用于返回 API 方法执行结果
fs 模块的所有异步API都有对应的同步版本，用于无法使用异步操作时，或者同步操作更方便时的情况。
同步API除了方法名的末尾多了一个 Sync 之外，异常对象与执行结果的传递方式也有相应变化
以fs.readFileSync为例：
```js
try {
  var data = fs.readFileSync(pathname)
  // Deal with data.
} catch (err) {
  // Deal with error.
}
```

**_Path_**
path.normalize 
将传入的路径转换为标准路径，具体讲的话，除了解析路径中的.与..外，还能去掉多余的斜杠
```js
var cache = {}
function store (key, value) {
    cache[path.normalize(key)] = value
}
store('foo/bar', 1)
store('foo//baz//../bar', 2)
console.log(cache)  // => { "foo/bar": 2 }
```
**坑出没注意**： 标准化之后的路径里的斜杠在Windows系统下是\，而在Linux系统下是/。如果想保证任何系统下都使用/作为路径分隔符的话，需要用.replace(/\\/g, '/')再替换一下标准路径。

path.join
将传入的多个路径拼接为标准路径。该方法可避免手工拼接路径字符串的繁琐，并且能在不同系统下正确使用相应的路径分隔符
```js
path.join('foo/', 'baz/', '../bar'); // => "foo/bar"
```

path.extname
当我们需要根据不同文件扩展名做不同操作时，该方法就显得很好用
```js
path.extname('foo/bar.js') // => ".js"
```

### 遍历目录
### 文本编码

如果不是很在意性能，fs模块的同步API能让生活更加美好
需要对文件读写做到字节级别的精细控制时，请使用fs模块的文件底层操作API
不要使用拼接字符串的方式来处理路径，使用path模块
掌握好目录遍历和文件编码处理技巧，很实用