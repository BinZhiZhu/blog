# 原型的继承方式收录

以一个父类为前提条件，列举 js 继承的继承方式：

```JavaScript
function Person (age) {
  this.age = age || 18
}
Person.prototype.sleep = function () {
  console.log('sleeping')
}
```

**🍖 方式 1：原型链继承（不推荐）**

将父类实例作为子类的原型

```JavaScript
function Programmer() {}

Programmer.prototype = new Person ()
Programmer.prototype.code = function () {
  console.log('coding')
}

let jon = new Programmer()
jon.code() // coding
jon.sleep() // sleeping

jon instanceof Person // true
jon instanceof Programmer // true

Object.getPrototypeOf(jon) // Person {age: 18, code: ƒ}
jon.__proto__ // Person {age: 18, code: ƒ}
```

缺点：

1. 新增原型属性方法，必须在 **new Person()** 之后，不然会被覆盖。
2. 创建子类实例时，无法向父类构造函数传参。
3. 无法多继承。
4. 父类的所有原型属性和方法被实例共享，只要一个子类实例修改了，其他所有的子类实例都会被影响。

**🌭 方式 2：构造继承（不推荐）**

复制父类**构造函数内的属性和方法**

```JavaScript
function Programmer(name) {
  Person.call(this)
  this.name = name
}
let jon = new Programmer('jon')
jon.name // jon
jon.age // 18

jon.sleep() // Uncaught TypeError: jon.sleep is not a function
jon instanceof Person // false
jon instanceof Programmer // true
```

缺点：

1. 只是子类的实例，不是父类的实例。
2. 还能继承父类构造函数的属性和方法，不能继承父类原型的属性和方法。

**🍗 方式 3：实例继承（不推荐）**

为父类实例添加新特性，作为子类实例返回

```JavaScript
function Programmer(name) {
  let instance = new Person()
  instance.name = name
  return instance
}

let jon = new Programmer('jon')
jon instanceof Person // true
jon instanceof Programmer // false
```

缺点：

1. 只是父类的实例，不是子类的实例。

**🍤 方式 4：组合继承（推荐）**

通过调用父类构造函数复制自身属性，将父类实例作为子类原型，继承原型的属性和方法

```JavaScript
function Programmer(age, name) {
  Person.call(this, age)
  this.name = name
}

Programmer.prototype = new Person()
Programmer.prototype.constructor = Programmer // 修复构造函数指向

let jon = new Programmer(18, 'jon')
jon.age // 18
jon.name // jon

let flash = new Programmer(22, 'flash')
flash.age // 22
flash.name // flash

jon.age // 18

jon instanceof Person // true
jon instanceof Programmer // true
flash instanceof Person // true
flash instanceof Programmer // true
```

优点：

1. 不存在引用属性共享问题

缺点：

1. 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）。

**🍳 方式 5： 寄生组合继承（推荐）**

子类构造函数复制父类的自身属性和方法，子类原型只接受父类的原型属性和方法

```JavaScript
function Super(prototype) {
  let Super = function () {}
  Super.prototype = prototype
  return new Super()
}

function Programmer(age, name) {
  Person.call(this, age)
  this.name = name
}

Programmer.prototype = Super(Person.prototype)
Programmer.prototype.constructor = Programmer // 修复构造函数指向

let jon = new Programmer(18, 'jon')
jon.age // 18
jon.name // jon

jon instanceof Person // true
jon instanceof Programmer // true
```

缺点：

1. 复杂。

**🍜 方式 6：ES6 extends（推荐）**

```JavaScript
// 父类
class Person {
  constructor(age) {
    this.age = age
  }
  sleep () {
    console.log('sleeping')
  }
}

// 子类
class Programmer extends Person {
  constructor(age, name) {
    super(age)
    this.name = name
  }
  code () {
    console.log('coding')
  }
}

let jon = new Programmer(18, 'jon')
jon.name // jon
jon.age // 18

let flash = new Programmer(22, 'flash')
flash.age // 22
flash.name // flash

jon instanceof Person // true
jon instanceof Programmer // true
flash instanceof Person // true
flash instanceof Programmer // true
```

优点：

1. 不用手动设置原型。

缺点：

1. 新语法，只要部分浏览器支持，需要转为 es5 代码。

## ❄️ 总结自：

- [JS 实现继承的几种方式](http://www.cnblogs.com/humin/p/4556820.html)
- [《ECMAScript 6 入门》Class 的继承一章](http://es6.ruanyifeng.com/#docs/class-extends)
